# vim:fileencoding=utf-8

eq = assert.equal
de = assert.deepEqual

def get(obj, name):
    return (obj) ? obj[name] : undefined

# Test the parsing of function definitions {{{

def basic_test(code, arglen, starargs, kwargs, defaults):
    func = RapydScript.parse('def function(' + code + '): pass\n', {'filename':code}).body[0]
    eq(func.argnames.length, arglen)
    eq(get(func.argnames.starargs, 'name'), starargs)
    eq(get(func.argnames.kwargs, 'name'), kwargs)
    eq(func.argnames.is_simple_func, bool(not starargs and not kwargs and not defaults))
    if defaults:
        fd = {}
        for key in Object.keys(func.argnames.defaults):
            fd[key] = func.argnames.defaults[key].value
        de(fd, defaults)
    return func

def throw_test(code):
    orig, RapydScript.AST_Node.warn_function = RapydScript.AST_Node.warn_function, def():pass
    assert.throws(def():
        RapydScript.parse('def function(' + code + '): pass\n', {'filename':code}).body[0]
    , RapydScript.JS_Parse_Error)
    RapydScript.AST_Node.warn_function = orig

basic_test('a, b, c', 3)
basic_test('*args', 0, 'args')
basic_test('a, b, *args', 2, 'args')
throw_test('*args, a')
throw_test('*args, *a')
basic_test('**kwargs', 0, undefined, 'kwargs')
basic_test('*args, **kwargs', 0, 'args', 'kwargs')
basic_test('a, b, *args, **kwargs', 2, 'args', 'kwargs')
throw_test('**kw, *a')
throw_test('**kw, **a')
basic_test('a=1, b="2"', 2, None, None, {'a':1, 'b':"2"})
basic_test('x, a=1, b="2", *args, **kw', 3, 'args', 'kw', {'a':1, 'b':"2"})
throw_test('a=1, b')
throw_test('**k, a=1')
throw_test('a, a')
throw_test('a, a=1')
throw_test('*a, **a')
# }}}

# Test parsing of function calls {{{

def parse_call_test(code, arglen, opts):
    func = RapydScript.parse('f(' + code + ')', {'filename':code}).body[0].body
    opts = opts or {}
    eq(func.args.length, arglen, 'Incorrect len for: ' + code)
    if (opts.starargs != undefined):
        si = [[i, x.name] for i, x in enumerate(func.args) if x.is_array]
        de(opts.starargs, si, 'starargs wrong for: ' + code + ': ' + si + ' != ' + opts.starargs)
    if (opts.kwargs != undefined):
        de(opts.kwargs, [x[0].name for x in func.args.kwargs])


parse_call_test('a, b, c', 3)
parse_call_test('*args', 1, {starargs:[[0, 'args']]})
parse_call_test('a, b, *args', 3, {starargs:[[2, 'args']]})
parse_call_test('a, *args, b, *a2', 4, {starargs:[[1, 'args'], [3, 'a2']]})
parse_call_test('a=1', 0, {kwargs:['a']})
parse_call_test('a=1, b', 1, {kwargs:['a']})
parse_call_test('a=1, b, **kwargs, *args, **k2', 2, {kwargs:['a'], kw:['kwargs', 'k2'], starargs:[[1,'args']]})
# }}}

# Test calling {{{

def f():
    return Array.prototype.slice.call(arguments)


de(f(1, 2, 3), [1, 2, 3])
args1, args2 = [4, 5, 6], [7, 8, 9]
kw1, kw2 = {a:4, b:5, c:6}, {a:7, x:8, y:9}

de(f(*args1), [4, 5, 6])
de(f(1, *args1), [1, 4, 5, 6])
de(f(*args1, 2), [4, 5, 6, 2])
de(f(1, *args1, 2), [1, 4, 5, 6, 2])
de(f(*args1, *args2), args1.concat(args2))
de(f(*args1, 1, 2, *args2, 3), [4, 5, 6, 1, 2, 7, 8, 9, 3])

de(f(1, a=2), [1, {a:2}])
de(f(1, a=2, 3), [1, 3, {a:2}])
de(f(**kw1), [kw1])
de(f(1, a=2, 3, **kw1), [1, 3, {a:2, b:5, c:6}])
de(f(**kw2, 1, 3, **kw1, 2), [1, 3, 2, {a:4, b:5, c:6, x:8, y:9}])

# }}}

# Test calling with definitions {{{

def f1(a, b, c):
    return a, b, c
de(f1(1, 2, 3), [1, 2, 3])
de(f1(), [undefined, undefined, undefined])

def f2(a, b=1):
    return a, b

de(f2(), [undefined, 1])
de(f2(1), [1, 1])
de(f2(1, 2), [1, 2])
de(f2(b=2), [{b:2}, 2])
de(f2(1, b=2), [1, 2])
de(f2({b:3}), [{b:3}, 1], 'a normal object is being treated as an options object')

def f3(*args):
    return args

de(f3(), [])
de(f3(1, 2), [1, 2])

def f4(**kwargs):
    return kwargs

de(f4(), {})
de(f4(a=1, b=2), {a:1, b:2})

def f5(*args, **kwargs):
    return [args, kwargs]

de(f5(), [[], {}])
de(f5(1, 2, a=1, b=2), [[1,2], {a:1, b:2}])

def f6(a, *args):
    return [a, args]

de(f6(), [undefined, []])
de(f6(1), [1, []])
de(f6(1, 2, 3), [1, [2, 3]])

def f7(a=1, **kw):
    return [a, kw]

de(f7(), [1, {}])
de(f7(a=3, b=4), [3, {b:4}])

def f8(a, b=2, *args, **kwargs):
    return [a, b, args, kwargs]

de(f8(), [undefined, 2, [], {}])
de(f8(1), [1, 2, [], {}])
de(f8(1, 3, 4, 5, b=8, c=9), [1, 8, [4, 5], {c:9}])

def f9(*args, **kwargs):
    return [args, kwargs]

de(f9(), [[], {}])
de(f9(1, 2, a=1, b=2), [[1,2], {a:1, b:2}])

def f10(a, b=2, c=3):
    return [a, b, c]

de(f10(1, c=6), [1, 2, 6])
# }}}

class Test:

    def __init__(self, a, b=2, *args, **kwargs):
        self.arguments = [a, b, args, kwargs]

de(Test().arguments, [undefined, 2, [], {}])
de(Test(1, 3, 4, 5, b=8, c=9).arguments, [1, 8, [4, 5], {c:9}])


from stdlib_common import options_object

@options_object
def callback(a, b=1, c=2):
    return [a, b, c]

de(callback(0, {c:4}), [0, 1, 4])
